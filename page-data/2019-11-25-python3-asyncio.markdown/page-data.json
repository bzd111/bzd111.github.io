{"componentChunkName":"component---src-templates-blog-post-js","path":"/2019-11-25-python3-asyncio.markdown/","result":{"data":{"markdownRemark":{"html":"<!-- vim-markdown-toc Redcarpet -->\n<ul>\n<li><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></li>\n<li><a href=\"#asyncio\">asyncio</a>\n<ul>\n<li><a href=\"#eventloop\">eventloop</a></li>\n<li><a href=\"#future-gatheringfuture\">Future(GatheringFuture)</a></li>\n<li><a href=\"#task\">Task</a></li>\n</ul>\n</li>\n<li><a href=\"#python3-7-%E4%B8%AD%E7%9A%84%E6%94%B9%E8%BF%9B\">Python3.7 中的改进</a></li>\n<li><a href=\"#%E7%96%91%E9%97%AE\">疑问</a>\n<ul>\n<li><a href=\"#future-%E4%B8%8E-task-%E7%9A%84%E4%B8%8D%E5%90%8C\">Future 与 Task 的不同</a></li>\n<li><a href=\"#ensure_future%E3%80%81create_task-%E5%B7%AE%E5%88%AB\">ensure_future、create_task 差别</a></li>\n<li><a href=\"#gather%E3%80%81wait-%E5%B7%AE%E5%88%AB\">gather、wait 差别</a></li>\n<li><a href=\"#%E5%8D%8F%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%80%8E%E4%B9%88%E6%B7%B7%E7%94%A8\">协程、多线程、多进程怎么混用</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD\">未完待续</a></li>\n<li><a href=\"#reference\">Reference</a></li>\n</ul>\n<!-- vim-markdown-toc -->\n<h1 id=\"前言\" style=\"position:relative;\"><a href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"前言 permalink\" class=\"toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前言</h1>\n<p>Python3，应该多使用 asyncio\n<strong>以下代码基于 python3.7</strong></p>\n<h1 id=\"asyncio\" style=\"position:relative;\"><a href=\"#asyncio\" aria-label=\"asyncio permalink\" class=\"toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>asyncio</h1>\n<p>由<a href=\"https://www.python.org/dev/peps/pep-3156/\">PEP3156</a>提出重启 asyncio，<a href=\"https://www.python.org/dev/peps/pep-0492/\">PEP492</a>优化写法。\n更到了 Python2 不在维护的时间点，应该多使用 Python3 异步 IO</p>\n<h2 id=\"eventloop\" style=\"position:relative;\"><a href=\"#eventloop\" aria-label=\"eventloop permalink\" class=\"toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>eventloop</h2>\n<p>一个线程只会有一个事件循环，用 <code class=\"language-text\">threading.local</code> 来存放 loop 和 pid，保证同一个线程的 loop 是相同的，和 Flask 中用到的管理上下文的类似。</p>\n<p>事件循环使用 selectors 模块，来实现异步 IO。</p>\n<h2 id=\"futuregatheringfuture\" style=\"position:relative;\"><a href=\"#futuregatheringfuture\" aria-label=\"futuregatheringfuture permalink\" class=\"toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Future(GatheringFuture)</h2>\n<p>asyncio 中的 Future 和 concurrent.futures 中的 Future 差不多兼容的，差别在于 asyncio 中的 Future 不是线程安全的。</p>\n<p>GatheringFuture 是 Future 的子类，用于批量运行一些任务，运行的结果放在一个列表中。</p>\n<h2 id=\"task\" style=\"position:relative;\"><a href=\"#task\" aria-label=\"task permalink\" class=\"toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Task</h2>\n<p>Task 是 Future 的子类，用来创建任务。</p>\n<p>所有的任务都会存在 weakref.WeakSet()集合中。通过内部的__step 来启动、执行 coroutine。</p>\n<h1 id=\"python37-中的改进\" style=\"position:relative;\"><a href=\"#python37-%E4%B8%AD%E7%9A%84%E6%94%B9%E8%BF%9B\" aria-label=\"python37 中的改进 permalink\" class=\"toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Python3.7 中的改进</h1>\n<p>python3.7 之前需要这么执行 main 方法</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">loop = asyncio.get_event_loop()\ntry:\n    loop.run_until_complete(main())\nfinally:\n    loop.close()</code></pre></div>\n<p>python3.7 之后只要这么一行</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">asyncio.run(main())</code></pre></div>\n<p>其实 asyncio.run 封装了类似的逻辑，它会新起一个 loop，去执行 main 方法。</p>\n<p>核心逻辑如下</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">loop = events.new_event_loop()\n    try:\n        events.set_event_loop(loop)\n        loop.set_debug(debug)\n        return loop.run_until_complete(main)\n    finally:\n        try:\n            _cancel_all_tasks(loop)\n            loop.run_until_complete(loop.shutdown_asyncgens())\n        finally:\n            events.set_event_loop(None)\n            loop.close()</code></pre></div>\n<h1 id=\"疑问\" style=\"position:relative;\"><a href=\"#%E7%96%91%E9%97%AE\" aria-label=\"疑问 permalink\" class=\"toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>疑问</h1>\n<h2 id=\"future-与-task-的不同\" style=\"position:relative;\"><a href=\"#future-%E4%B8%8E-task-%E7%9A%84%E4%B8%8D%E5%90%8C\" aria-label=\"future 与 task 的不同 permalink\" class=\"toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Future 与 Task 的不同</h2>\n<h2 id=\"ensure_futurecreate_task-差别\" style=\"position:relative;\"><a href=\"#ensure_futurecreate_task-%E5%B7%AE%E5%88%AB\" aria-label=\"ensure_futurecreate_task 差别 permalink\" class=\"toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ensure_future、create_task 差别</h2>\n<p>loop.create_task 和 asyncio.create_task，都有这个功能，官方文档推荐使用 asyncio.create_task</p>\n<p>asyncio.create_task 其实是封装了 loop.create_task 的，loop.create_task 其实是调用了 BaseEventLoop 的 create_task，创建一个 Task 对象</p>\n<p>ensure_future 根据传入参数不同的类型，进行不同的处理。</p>\n<p>如果是 coroutine 也是调用 create_task，如果是 future 类型直接返回，如果是 awaitable 类型，_wrap_awaitable 包装一下，再调用一次 ensure_future</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def ensure_future(coro_or_future, *, loop=None):\n    \"\"\"Wrap a coroutine or an awaitable in a future.\n\n    If the argument is a Future, it is returned directly.\n    \"\"\"\n    if coroutines.iscoroutine(coro_or_future):\n        if loop is None:\n            loop = events.get_event_loop()\n        task = loop.create_task(coro_or_future)\n        if task._source_traceback:\n            del task._source_traceback[-1]\n        return task\n    elif futures.isfuture(coro_or_future):\n        if loop is not None and loop is not futures._get_loop(coro_or_future):\n            raise ValueError('loop argument must agree with Future')\n        return coro_or_future\n    elif inspect.isawaitable(coro_or_future):\n        return ensure_future(_wrap_awaitable(coro_or_future), loop=loop)\n    else:\n        raise TypeError('An asyncio.Future, a coroutine or an awaitable is '\n                        'required')</code></pre></div>\n<h2 id=\"gatherwait-差别\" style=\"position:relative;\"><a href=\"#gatherwait-%E5%B7%AE%E5%88%AB\" aria-label=\"gatherwait 差别 permalink\" class=\"toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gather、wait 差别</h2>\n<p>gather、wait，都能执行一批任务，不同的是返回值。</p>\n<p>gather 返回的是执行结果，不分先后顺序。</p>\n<p>wait 返回两个值，分别是完成的任务和未完成的任务，然后可以遍历完成的任务获取结果，通过 Future 的 result 方法。对未完成的任务可以进行处理。</p>\n<p>如果单纯的执行，不关注结果或只关注结果可以使用 gather。</p>\n<h2 id=\"协程多线程多进程怎么混用\" style=\"position:relative;\"><a href=\"#%E5%8D%8F%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%80%8E%E4%B9%88%E6%B7%B7%E7%94%A8\" aria-label=\"协程多线程多进程怎么混用 permalink\" class=\"toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>协程、多线程、多进程怎么混用</h2>\n<p>有了协程，以往的多进程(处理计算密集型)、多线程(处理 IO 密集型)是不是无用武之地了？</p>\n<p>当然不是，异步代码，需要你所有的操作都是异步的，当然这个不太可能的，所有需要使用 loop.run_in_executor 来执行同步代码，</p>\n<p>像官方代码中的 getaddrinfo、getnameinfo 等都有使用的这个方法。</p>\n<p>值得一提的是，run_in_executor(executor, func, *args)，有三个参数，如果 executor 参数是 None 的话，就会通过 concurrent.futures.ThreadPoolExecutor()创建一个。</p>\n<p>如果同步代码较多的话，可以在代码开头先创建一个线程池或进程池，达到复用的目的。</p>\n<h1 id=\"未完待续\" style=\"position:relative;\"><a href=\"#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD\" aria-label=\"未完待续 permalink\" class=\"toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>未完待续</h1>\n<h1 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"toc-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h1>\n<ul>\n<li><a href=\"https://docs.python.org/zh-cn/3.7/library/asyncio-task.html\">https://docs.python.org/zh-cn/3.7/library/asyncio-task.html</a></li>\n<li><a href=\"https://realpython.com/async-io-python/#other-features-async-for-and-async-generators-comprehensions\">https://realpython.com/async-io-python/#other-features-async-for-and-async-generators-comprehensions</a></li>\n<li><a href=\"https://www.pythonsheets.com/notes/python-asyncio.html\">https://www.pythonsheets.com/notes/python-asyncio.html</a></li>\n<li><a href=\"https://www.dongwm.com/post/understand-asyncio-1/\">https://www.dongwm.com/post/understand-asyncio-1/</a></li>\n<li><a href=\"https://www.dongwm.com/post/understand-asyncio-2/\">https://www.dongwm.com/post/understand-asyncio-2/</a></li>\n<li><a href=\"https://www.dongwm.com/post/understand-asyncio-3/\">https://www.dongwm.com/post/understand-asyncio-3/</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></p>\n</li>\n<li>\n<p><a href=\"#asyncio\">asyncio</a></p>\n<ul>\n<li><a href=\"#eventloop\">eventloop</a></li>\n<li><a href=\"#futuregatheringfuture\">Future(GatheringFuture)</a></li>\n<li><a href=\"#task\">Task</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#python37-%E4%B8%AD%E7%9A%84%E6%94%B9%E8%BF%9B\">Python3.7 中的改进</a></p>\n</li>\n<li>\n<p><a href=\"#%E7%96%91%E9%97%AE\">疑问</a></p>\n<ul>\n<li><a href=\"#future-%E4%B8%8E-task-%E7%9A%84%E4%B8%8D%E5%90%8C\">Future 与 Task 的不同</a></li>\n<li><a href=\"#ensure_futurecreate_task-%E5%B7%AE%E5%88%AB\">ensure_future、create_task 差别</a></li>\n<li><a href=\"#gatherwait-%E5%B7%AE%E5%88%AB\">gather、wait 差别</a></li>\n<li><a href=\"#%E5%8D%8F%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%80%8E%E4%B9%88%E6%B7%B7%E7%94%A8\">协程、多线程、多进程怎么混用</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD\">未完待续</a></p>\n</li>\n<li>\n<p><a href=\"#reference\">Reference</a></p>\n</li>\n</ul>","frontmatter":{"title":"python3 asyncio使用","date":"2019-11-25"}}},"pageContext":{"slug":"/2019-11-25-python3-asyncio.markdown"}},"staticQueryHashes":["3649515864"],"slicesMap":{}}